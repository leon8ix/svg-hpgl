{"version":3,"file":"svg-path.js","sourceRoot":"","sources":["../src/svg-path.ts"],"names":[],"mappings":"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","sourcesContent":["// M224.4,410.1,204,363s44.151-25.489,47.337,3.186,23.669,18.662,23.669,18L254.893,423.3\r\n\r\nimport type { FixedArray, KeysOfUnion } from './ts-utils';\r\n\r\nconst cmdLengths = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 } as const satisfies Record<\r\n\tstring,\r\n\tnumber\r\n>;\r\n\r\nexport type PathCommand = keyof typeof cmdLengths;\r\n\r\nexport type CommandVals = { [K in PathCommand]: FixedArray<number, (typeof cmdLengths)[K]> };\r\n\r\n// TODO: implement vals with FixedArray\r\nexport type PathInstructionRaw = { cmd: PathCommand; rel: boolean; vals: number[] };\r\n\r\nexport type PathInstruction =\r\n\t/** Move to (first command, lift pointer, don't draw) */\r\n\t| { cmd: 'M'; rel: boolean; x: number; y: number }\r\n\t/** Line to */\r\n\t| { cmd: 'L'; rel: boolean; x: number; y: number }\r\n\t/** Horizontal */\r\n\t| { cmd: 'H'; rel: boolean; x: number }\r\n\t/** Vertical */\r\n\t| { cmd: 'V'; rel: boolean; y: number }\r\n\t/** Cubic bézier curve (most design software) */\r\n\t| { cmd: 'C'; rel: boolean; x1: number; y1: number; x2: number; y2: number; x: number; y: number }\r\n\t/** Smooth cubic bézier curve (control point 1 is implied by previous path) */\r\n\t| { cmd: 'S'; rel: boolean; x2: number; y2: number; x: number; y: number }\r\n\t/** Quadratic bézier curve */\r\n\t| { cmd: 'Q'; rel: boolean; x1: number; y1: number; x: number; y: number }\r\n\t/** Smooth quadratic bézier curve (control point is implied by previous path) */\r\n\t| { cmd: 'T'; rel: boolean; x: number; y: number }\r\n\t/** Arc (partial ellipse) */\r\n\t| {\r\n\t\t\tcmd: 'A';\r\n\t\t\trel: boolean;\r\n\t\t\trx: number;\r\n\t\t\try: number;\r\n\t\t\txAxisRotation: number;\r\n\t\t\tlargeArcFlag: 0 | 1;\r\n\t\t\tsweepFlag: 0 | 1;\r\n\t\t\tx: number;\r\n\t\t\ty: number;\r\n\t  }\r\n\t/** Close path (at the end) */\r\n\t| { cmd: 'Z'; rel: false };\r\n\r\n/** All-in-one SVG path parsing function, returns `readable`, `absolute` path commands */\r\nexport function parsePath(d: string) {\r\n\treturn toAbsolute(parsePathSyntax(d).map(ins => keyPathInstruction(ins)));\r\n}\r\n\r\n/** Basic decoding of path syntax to raw instructions */\r\nexport function parsePathSyntax(d: string): PathInstructionRaw[] {\r\n\tconst pathSeq: PathInstructionRaw[] = [];\r\n\tlet cmd: PathCommand = 'M';\r\n\tlet rel = false;\r\n\tlet token = '';\r\n\tlet isFloat = false;\r\n\tconst vals: number[] = [];\r\n\r\n\tfunction finishToken() {\r\n\t\tif (!token.length) return;\r\n\t\tconst num = parseFloat(token);\r\n\t\tif (typeof num === 'number' && !isNaN(num)) vals.push(num);\r\n\t\ttoken = '';\r\n\t\tisFloat = false;\r\n\t}\r\n\r\n\tfunction finishCommand() {\r\n\t\tfinishToken();\r\n\t\tconst cmdLength = cmdLengths[cmd];\r\n\t\tif (cmdLength) {\r\n\t\t\tif (!vals.length) return;\r\n\t\t\tconst cmdCount = Math.floor(vals.length / cmdLength);\r\n\t\t\tfor (let i = 0; i < cmdCount; i++) {\r\n\t\t\t\tconst firstValI = i * cmdLength;\r\n\t\t\t\tconst lastValI = firstValI + cmdLength;\r\n\t\t\t\tpathSeq.push({ cmd, rel, vals: vals.slice(firstValI, lastValI) });\r\n\t\t\t}\r\n\t\t} else if (cmdLength === 0) {\r\n\t\t\tpathSeq.push({ cmd, rel, vals: [] });\r\n\t\t}\r\n\t\tvals.length = 0;\r\n\t}\r\n\r\n\t// TODO: after M with two vals, ther is an implicit L :/\r\n\r\n\tfor (const c of d) {\r\n\t\tif (isLetter(c)) {\r\n\t\t\tfinishCommand();\r\n\t\t\tconst upperCmd = c.toUpperCase();\r\n\t\t\tif (!(upperCmd in cmdLengths)) continue;\r\n\t\t\tcmd = upperCmd as PathCommand;\r\n\t\t\trel = isLowercase(c);\r\n\t\t} else if (c === ',' || c === ' ') {\r\n\t\t\tfinishToken();\r\n\t\t} else if (c === '.') {\r\n\t\t\tif (isFloat) finishToken();\r\n\t\t\ttoken += c;\r\n\t\t\tisFloat = true;\r\n\t\t} else if (c === '-') {\r\n\t\t\tfinishToken();\r\n\t\t\ttoken += c;\r\n\t\t} else if (isDigit(c)) {\r\n\t\t\ttoken += c;\r\n\t\t}\r\n\t}\r\n\tfinishCommand();\r\n\r\n\treturn pathSeq;\r\n}\r\n\r\nfunction isLetter(c: string): boolean {\r\n\treturn c.toLowerCase() !== c.toUpperCase();\r\n}\r\nfunction isLowercase(c: string): boolean {\r\n\treturn c !== c.toUpperCase();\r\n}\r\nfunction isDigit(c: string): boolean {\r\n\treturn c === String(parseInt(c));\r\n}\r\n\r\nexport function keyPathInstruction({ cmd, rel, vals }: PathInstructionRaw): PathInstruction {\r\n\tswitch (cmd) {\r\n\t\tcase 'M':\r\n\t\t\treturn mapArrayIndex(vals, ['x', 'y'], 0, { cmd, rel });\r\n\t\tcase 'L':\r\n\t\t\treturn mapArrayIndex(vals, ['x', 'y'], 0, { cmd, rel });\r\n\t\tcase 'H':\r\n\t\t\treturn mapArrayIndex(vals, ['x'], 0, { cmd, rel });\r\n\t\tcase 'V':\r\n\t\t\treturn mapArrayIndex(vals, ['y'], 0, { cmd, rel });\r\n\t\tcase 'C':\r\n\t\t\treturn mapArrayIndex(vals, ['x1', 'y1', 'x2', 'y2', 'x', 'y'], 0, { cmd, rel });\r\n\t\tcase 'S':\r\n\t\t\treturn mapArrayIndex(vals, ['x2', 'y2', 'x', 'y'], 0, { cmd, rel });\r\n\t\tcase 'Q':\r\n\t\t\treturn mapArrayIndex(vals, ['x1', 'y1', 'x', 'y'], 0, { cmd, rel });\r\n\t\tcase 'T':\r\n\t\t\treturn mapArrayIndex(vals, ['x', 'y'], 0, { cmd, rel });\r\n\t\tcase 'A':\r\n\t\t\treturn {\r\n\t\t\t\tcmd,\r\n\t\t\t\trel,\r\n\t\t\t\trx: vals[0] ?? 0,\r\n\t\t\t\try: vals[1] ?? 0,\r\n\t\t\t\txAxisRotation: vals[2] ?? 0,\r\n\t\t\t\tlargeArcFlag: vals[3] ? 1 : 0,\r\n\t\t\t\tsweepFlag: vals[4] ? 1 : 0,\r\n\t\t\t\tx: vals[5] ?? 0,\r\n\t\t\t\ty: vals[6] ?? 0,\r\n\t\t\t};\r\n\t\tcase 'Z':\r\n\t\t\treturn { cmd, rel: false };\r\n\t}\r\n}\r\n\r\nfunction mapArrayIndex<T, K extends string, O extends Record<string, any>>(\r\n\tarr: T[],\r\n\tkeys: K[],\r\n\tfallback: T,\r\n\tbaseObj?: O\r\n) {\r\n\tconst obj = (baseObj as O & Record<K, T>) || ({} as Record<K, T>);\r\n\t// @ts-expect-error\r\n\tkeys.forEach((key, i) => (obj[key] = arr[i] ?? fallback));\r\n\treturn obj;\r\n}\r\n\r\n/** Transforms all commands to absolute, modifies original objects and returns same ref */\r\nfunction toAbsolute(instructions: PathInstruction[]): PathInstruction[] {\r\n\tlet currX = 0;\r\n\tlet currY = 0;\r\n\tfunction updateCurr(ins: PathInstruction) {\r\n\t\tif ('x' in ins) currX = ins.x;\r\n\t\tif ('y' in ins) currY = ins.y;\r\n\t}\r\n\tinstructions.forEach(ins => {\r\n\t\tif (!ins.rel) return updateCurr(ins);\r\n\t\tins.rel = false;\r\n\t\tconst keys = Object.keys(ins) as KeysOfUnion<typeof ins>[];\r\n\t\t// @ts-expect-error\r\n\t\tkeys.filter(key => key.startsWith('x')).forEach(key => (ins[key] += currX));\r\n\t\t// @ts-expect-error\r\n\t\tkeys.filter(key => key.startsWith('y')).forEach(key => (ins[key] += currY));\r\n\t\tupdateCurr(ins);\r\n\t});\r\n\treturn instructions;\r\n}\r\n"]}